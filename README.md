# Frontend Conf 2018 Summary

## Building decentralised apps with JS

### Web3.js
* Подключение к ноде
* Вызов методов, получение стейта
* Работа с акком юзера
* Отправка транзакций
* Валидация статуса транзакций

### Ganache: локальная нода ( локальный блокчейн)
* Настраиваемые параметры сети
* Работа приложения e2e

### Truffle - экосистема для разработки

#### Truffle suite
* компиляция контрактов
* тестирование
* миграция/деплой в сеть

#### Truffle boxes
* готовые демо-проекты
* boilerplate-интеграции


## Mining crypto in browser

### Coin
[XMR Monero](https://moneroexplorer.com/)
### Plugins
* [Coinhive](https://coinhive.com/)
* [Coinimp](https://www.coinimp.com/)


## Apollo - год спустя

### GraphQL
Плюсы:
* самодокуметируемый (дока генериться автоматически)
* получили то, что запросили
* оперирование сущностями и связями между ними, а не отдельными эндпоинтами

Минусы:
* Глубокая вложенность https://github.com/stems/graphql-depth-limit
* работа с файлами https://github.com/jaydenseric/graphql-multipart-request-spec
* N+1 query https://github.com/facebook/dataloader

### Relay
Плюсы:
* Продукт fb
* relay-compiler - для оптимизации и анализа graphQL

Минусы:
* Нет ssr из коробки
* офф решение только для реакта
* сложность из-за дополнительной спецификации (хз насколько это минус)
  Например использование курсоров(first), вместо лимитов

### Apollo (продукт от Meteor)
Плюсы:
* framework agnostic (взаимодействие с graphQL сервером не зависит от фреймворка)
* хорошая документация
* мощный API (чем-то похоже на Redux)

Минусы:
* производительность (проблема решенная)
* неочевидный refetch (при перезапросе данных статус loading не уходит в true, его нужно хранить где-то отдельно, либо флаг notifyOnNetworkStatusChange: true)

#### Появились куча тулзов для работы с graphql:
* vscode plugin
* девтулзы
* graphQL faker and etc
* apollo boost (starter)


## Реактивное программирование: как думать реактивно, а не проактивно
"разрабатываю велосипеды"

### Либы:
* rx.js
* bacon.js
* xstreams
* kefir.js
* most.js

### Написали свой State Manager на Rx.js
Плюсы:
* Уменьшилось кол-во ошибок
* Изменения поставляются через потоки в любые заинтересованные уголки приложения
* Данные сами запускают все алгоритмы
* Ощущение постоянного давления со стороны потоков
* Тормоза интерфейса
* Сильная связанность компонентов со State Manager’ами
* Приходилось бороться с излишней активностью потоков

Минусы:
* Ощущение постоянного давления со стороны потоков
* Тормоза интерфейса
* Сильная связанность компонентов со State Manager’ами
* Приходилось бороться с излишней активностью потоков

Дальше история о том как они все улучшали с примеры из Ангуляра

### Либа для редакса:
[Redux Observable](https://redux-observable.js.org/)

### Проблемы:
Утечка памяти. Как сделать авто-отписку от потоков? - НИКАК!

Потом какие-то бла бла бла про это проблему и как нужно делать правильно.

